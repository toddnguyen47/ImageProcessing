/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package imgpro;

import imgpro.adaptivecanny.AdaptiveCanny;
import imgpro.gaussianblur.Autocorrelation;
import imgpro.gaussianblur.EdgeDetection;
import imgpro.gaussianblur.GaussianBlur;
import imgpro.histogram.HistogramEqualization;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

/**
 *
 * @author ToddNguyen
 */
public class MainWindow extends javax.swing.JFrame {
	
	/**
	 * Creates new form MainWindow
	 */
    public MainWindow() {
		initImage = new InitImage();
		initComponents();
		this.getRootPane().setDefaultButton(btnExecute);
	}

	/**
	 * This method is called from within the constructor to initialize the form. WARNING: Do NOT
	 * modify this code. The content of this method is always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jPanel1 = new javax.swing.JPanel();
        btnInsertImage = new javax.swing.JButton();
        labelInitImage = new javax.swing.JLabel();
        cboxAction = new javax.swing.JComboBox<>();
        jLabel2 = new javax.swing.JLabel();
        btnExecute = new javax.swing.JButton();
        cboxAlgo = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        textFieldWidth = new FocusTextField();
        textFieldHeight = new FocusTextField();
        lblText1 = new javax.swing.JLabel();
        lblText2 = new javax.swing.JLabel();
        labelNewImage = new javax.swing.JLabel();
        jLabelBits1 = new javax.swing.JLabel();
        cboxBitSelection = new javax.swing.JComboBox<Integer>();
        btnConvertInit = new javax.swing.JButton();
        cboxBitSelection1 = new javax.swing.JComboBox<Integer>();
        jLabelBits2 = new javax.swing.JLabel();
        jCheckHistogram = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Main Window");
        setSize(new java.awt.Dimension(1280, 720));

        jScrollPane1.setPreferredSize(new java.awt.Dimension(1280, 720));

        jPanel1.setPreferredSize(new java.awt.Dimension(1280, 720));

        btnInsertImage.setText("Insert Picture");
        btnInsertImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnInsertImageActionPerformed(evt);
            }
        });

        labelInitImage.setText("labelInitImage");
        labelInitImage.setMaximumSize(new java.awt.Dimension(512, 512));
        labelInitImage.setMinimumSize(new java.awt.Dimension(10, 10));
        labelInitImage.setText("");

        cboxAction.setModel(new DefaultComboBoxModel<String>
            (ACTION_CHOICES));
        cboxAction.setSelectedItem(new DefaultComboBoxModel<String>(ACTION_CHOICES));
        cboxAction.setToolTipText("Change the zoom-in feature");
        cboxAction.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cboxActionActionPerformed(evt);
            }
        });

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel2.setText("Action");

        btnExecute.setText("Execute");
        btnExecute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExecuteActionPerformed(evt);
            }
        });

        String action = cboxAction.getSelectedItem().toString();
        if (action.compareToIgnoreCase("Zoom Out") == 0) {
            cboxAlgo.setEnabled(true);
        }
        else {
            cboxAlgo.setEnabled(false);
        }
        cboxAlgo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cboxAlgoActionPerformed(evt);
            }
        });

        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel4.setText("Algorithm");

        textFieldWidth.setText("1");
        textFieldWidth.setToolTipText("New Width");
        //textFieldWidth.getDocument().addDocumentListener(new DocumentListener() {
            //	public void changedUpdate(DocumentEvent e) {setOtherTextField();}
            //	public void removeUpdate(DocumentEvent e){setOtherTextField();};
            //	public void insertUpdate(DocumentEvent e){setOtherTextField();};
            //
            //	private void setOtherTextField() {
                //		String action = cboxAction.getSelectedItem().toString();
                //		String algo = cboxAlgo.getSelectedItem().toString();
                //		if	(action.contains("Spatial Filtering") &&
                    //			(!algo.contains("High-boost") && !algo.contains("Contraharmonic")
                        //			&& !algo.contains("Alpha-trimmed") )) {
                    //			textFieldHeight.setText(textFieldWidth.getText());
                    //		}
                //	}
            //});

    textFieldHeight.setEditable(false);
    textFieldHeight.setText("1");
    textFieldHeight.setToolTipText("New Height");

    lblText1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    lblText1.setText("Sigma");

    lblText2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    lblText2.setText("");

    labelNewImage.setText("newImage");
    labelNewImage.setText("");
    labelNewImage.setMaximumSize(new java.awt.Dimension(8192, 8192));
    labelNewImage.setMinimumSize(new java.awt.Dimension(32, 32));
    labelInitImage.setText("");

    jLabelBits1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabelBits1.setText("Low");

    Integer[] numberOfBits = new Integer[MAX_BIT];
    for (int i = 0; i < MAX_BIT; i++) {
        numberOfBits[i] = i + 1;
    }
    cboxBitSelection.setModel(new javax.swing.DefaultComboBoxModel<Integer>(numberOfBits));
    cboxBitSelection.setSelectedIndex(MAX_BIT - 1);
    cboxBitSelection.setEnabled(false);
    cboxBitSelection.addActionListener(new java.awt.event.ActionListener() {
        public void actionPerformed(java.awt.event.ActionEvent evt) {
            cboxBitSelectionActionPerformed(evt);
        }
    });

    btnConvertInit.setText("Convert to Initial Picture");
    btnConvertInit.addActionListener(new java.awt.event.ActionListener() {
        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnConvertInitActionPerformed(evt);
        }
    });

    numberOfBits = new Integer[MAX_BIT];
    for (int i = 0; i < MAX_BIT; i++) {
        numberOfBits[i] = i + 1;
    }
    cboxBitSelection1.setModel(new javax.swing.DefaultComboBoxModel<Integer>(numberOfBits));
    cboxBitSelection1.setSelectedIndex(MAX_BIT - 1);
    cboxBitSelection1.setEnabled(false);

    jLabelBits2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabelBits2.setText("High");

    jCheckHistogram.setText("Perform Histogram Equalization on resulting image");

    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(
        jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
            .addGap(17, 17, 17)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                    .addGap(19, 19, 19)
                    .addComponent(btnInsertImage)
                    .addGap(32, 32, 32)
                    .addComponent(cboxAction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addGap(148, 148, 148)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)))
            .addGap(30, 30, 30)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                .addComponent(cboxAlgo, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGap(30, 30, 30)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(lblText1)
                .addComponent(textFieldWidth, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                .addComponent(textFieldHeight)
                .addComponent(lblText2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGap(30, 30, 30)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(cboxBitSelection, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(jLabelBits1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGap(21, 21, 21)))
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(jLabelBits2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGap(43, 43, 43))
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(cboxBitSelection1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(btnExecute)
                    .addGap(30, 30, 30)
                    .addComponent(btnConvertInit))
                .addComponent(jCheckHistogram))
            .addGap(636, 636, 636))
        .addGroup(jPanel1Layout.createSequentialGroup()
            .addGap(19, 19, 19)
            .addComponent(labelInitImage, javax.swing.GroupLayout.PREFERRED_SIZE, 512, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addGap(31, 31, 31)
            .addComponent(labelNewImage, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
    );
    jPanel1Layout.setVerticalGroup(
        jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
        .addGroup(jPanel1Layout.createSequentialGroup()
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addGap(27, 27, 27)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel2)
                        .addComponent(jLabel4)
                        .addComponent(lblText1)
                        .addComponent(lblText2)
                        .addComponent(jLabelBits1)
                        .addComponent(jLabelBits2))
                    .addGap(5, 5, 5))
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(jCheckHistogram)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(btnInsertImage)
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addGap(1, 1, 1)
                    .addComponent(cboxAction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cboxAlgo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(textFieldWidth, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnExecute)
                    .addComponent(textFieldHeight, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cboxBitSelection, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnConvertInit)
                    .addComponent(cboxBitSelection1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
            .addGap(86, 86, 86)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                .addComponent(labelInitImage, javax.swing.GroupLayout.PREFERRED_SIZE, 513, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addComponent(labelNewImage, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
    );

    jScrollPane1.setViewportView(jPanel1);

    getContentPane().add(jScrollPane1, java.awt.BorderLayout.CENTER);

    pack();
    }// </editor-fold>//GEN-END:initComponents

	private void btnExecuteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExecuteActionPerformed
		String actionChosen = cboxAction.getSelectedItem().toString();
		//String algoChosen = cboxAlgo.getSelectedItem().toString();
		
		if (initPicLoaded()) {
			convertedImage = null;
			double tempImage[][] = null;
			double sigma = 0;
			try {
				sigma = Double.valueOf(textFieldWidth.getText());
			} catch (NumberFormatException e) {
				JOptionPane.showMessageDialog(this, "Sigma is not an integer.");
			}
			
			// Gaussian blur
			if (actionChosen.contains(ACTION_CHOICES[0])) {
				tempImage = GaussianBlur.getInstance().gaussianBlur(initImage.getImageArrayForm(), sigma);
			}
			// Edge detection
			else if (actionChosen.contains(ACTION_CHOICES[1])) {		
				int lowThreshold = 45;
				int highThreshold = 90;
				try {
					lowThreshold = Integer.parseInt(cboxBitSelection1.getSelectedItem().toString());
					highThreshold = Integer.parseInt(cboxBitSelection.getSelectedItem().toString());
				} catch (NumberFormatException e) {
					JOptionPane.showMessageDialog(this, "High/Low thresholds are not integers");
				}
				
				convertedImage = EdgeDetection.getInstance().edgeDetect(initImage.getImageArrayForm(), sigma,
						lowThreshold, highThreshold);
				int randomEdge[][] = EdgeDetection.getInstance().getRandomEdgeCells(convertedImage,100);
			}
			// Adaptive Canny Blurring
            else if (actionChosen.contains(ACTION_CHOICES[2])) {
				int JNCD = 0;
				double K = 0;
				try {
					K = Double.valueOf(textFieldWidth.getText());
					JNCD = Integer.valueOf(textFieldHeight.getText());
				} catch (NumberFormatException e) {
					JOptionPane.showMessageDialog(this, "JNCD is not an integer");
				}
				tempImage = AdaptiveCanny.getInstance().adaptiveBlurring(initImage.getImageArrayForm(),
						JNCD, K);
			}
			// Adaptive Canny
			else if (actionChosen.contains(ACTION_CHOICES[3])) {
				int JNCD = 0;
				double K = 0;
				try {
					K = Double.valueOf(textFieldWidth.getText());
					JNCD = Integer.valueOf(textFieldHeight.getText());
				} catch (NumberFormatException e) {
					JOptionPane.showMessageDialog(this, "JNCD is not an integer");
				}
				convertedImage = AdaptiveCanny.getInstance().getAdaptiveFilter(initImage.getImageArrayForm(),
						JNCD, K);
			}
			
			if (tempImage != null) {
				convertedImage = MainWindow.scaledRgbInt(tempImage);
			}
			
			if (convertedImage != null) {
				if (jCheckHistogram.isSelected()) {
					convertedImage = HistogramEqualization.getInstance().histEqual(evt, 
						this, initImage.getCurrentBit(), convertedImage, MainWindow.HIST_CHOICES[0]);
				}
				setNewImage(convertedImage, MainWindow.NEW_IMAGE);
			}
		}
	}//GEN-LAST:event_btnExecuteActionPerformed

	
	/**
	 * Obtain the gray-scale RGB value.
	 * @param imageArr Initial image
	 * @param row1
	 * @param col1
	 * @param row2
	 * @param col2
	 * @param curRowOrCol - int of current row or current col
	 * @param factor
	 * @return 
	 */
	public static final int getGrayValue(int[][] imageArr, int row1, int col1, int row2,
			int col2, int curRowOrCol, double factor) {
		int grValue1 = imageArr[row1][col1];
		int grValue2 = imageArr[row2][col2];
		int grDiff = grValue2 - grValue1;
		double indexDiff = (curRowOrCol % factor);
		return grValue1 + customRound(grDiff * (indexDiff / factor));
	}
	
	private void cboxActionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cboxActionActionPerformed
		String action = cboxAction.getSelectedItem().toString();
		setAlgorithms(action);
		setTextFields(action);
		setThresholds(action);
	}//GEN-LAST:event_cboxActionActionPerformed

	private void setAlgorithms(String action) {
		//TODO : DELETE?
	}
	
	private void setTextFields(String action) {		
		lblText1.setText("Sigma");
		textFieldWidth.setText("1");
		
		if (action.toUpperCase().contains("ADAPTIVE CANNY")) {
			lblText1.setText("K Constant");
			lblText2.setText("JNCD");
			textFieldHeight.setText("20");
			textFieldHeight.setEditable(true);
			textFieldWidth.setText("1.2");
		} else {
			lblText2.setText("");
			textFieldHeight.setText(textFieldWidth.getText());
			textFieldHeight.setEditable(false);
		}
	}
	
	private void setThresholds(String action) {
		if (action.toUpperCase().contains("CANNY EDGE")) {
			cboxBitSelection.setEnabled(true);
			cboxBitSelection1.setEnabled(true);
			Integer numberOfBits[] = new Integer[MAX_GRAYSCALE_VALUE];
			for (int i = 0; i < MAX_GRAYSCALE_VALUE; i++) {
				numberOfBits[i] = i + 1;
			}
			DefaultComboBoxModel<Integer> model = new DefaultComboBoxModel<>(numberOfBits);
			cboxBitSelection.setModel(model);
			cboxBitSelection1.setModel(model);
			cboxBitSelection.getModel().setSelectedItem("45"); // default low bit = 45
			cboxBitSelection1.getModel().setSelectedItem("90"); // default high bit = 90
		} else {
			cboxBitSelection.setEnabled(false);
			cboxBitSelection1.setEnabled(false);
		}
	}
	
	private void btnInsertImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnInsertImageActionPerformed
		jFileChooser1 = new javax.swing.JFileChooser();
		jFileChooser1.setCurrentDirectory(new File(System.getProperty("user.dir")));
		int returnVal = jFileChooser1.showOpenDialog(this);
		int initPictureWidth = 0;
		int initPictureHeight = 0;

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			try {
				BufferedImage img = ImageIO.read(jFileChooser1.getSelectedFile());
				
				initPictureWidth = img.getWidth();
				initPictureHeight = img.getHeight();				
								
				initImage.setInitBufferedImage(img);
				initImage.setCurrentBit(MAX_BIT);
				setNewImage(initImage.getImageArrayForm(), MainWindow.INIT_IMAGE);
			} catch (IOException e) {
				e.printStackTrace(System.out);
			}
		}
		
		String action = cboxAction.getSelectedItem().toString();
		if (action.contains("Zoom")) {
			textFieldWidth.setText(String.valueOf(initPictureWidth >> 1));
			textFieldHeight.setText(String.valueOf(initPictureHeight >> 1));
		}
	}//GEN-LAST:event_btnInsertImageActionPerformed

	private void btnConvertInitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConvertInitActionPerformed
		if (initPicLoaded()) {
			if (convertedImage != null) {
				initImage.setImageFromArray(convertedImage);
				if (currentConvBit >= 0) {
					initImage.setCurrentBit(currentConvBit);
				}
				
				labelInitImage.setSize(initImage.getWidth(), initImage.getHeight());
				labelInitImage.setIcon(initImage.getImageIcon());
			} else {
				JOptionPane.showMessageDialog(this, "No transformed image.");
			}
		}
	}//GEN-LAST:event_btnConvertInitActionPerformed

    private void cboxAlgoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cboxAlgoActionPerformed
        String actionChosen = cboxAction.getSelectedItem().toString();
		String algoChosen = cboxAlgo.getSelectedItem().toString();
    }//GEN-LAST:event_cboxAlgoActionPerformed

    private void cboxBitSelectionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cboxBitSelectionActionPerformed
        int chosen = Integer.parseInt(cboxBitSelection.getSelectedItem().toString());
		int prevValue = Integer.parseInt(cboxBitSelection1.getSelectedItem().toString());
		
		Integer bitSelection[] = new Integer[MAX_GRAYSCALE_VALUE - chosen];
		int index = 0;
		for (int i = 0; i < MAX_GRAYSCALE_VALUE; i++) {
			if (i >= chosen) bitSelection[index++] = i;
		}
		DefaultComboBoxModel<Integer> model = new DefaultComboBoxModel<>(bitSelection);
		cboxBitSelection1.setModel(model);
		
		if (prevValue >= chosen) {
			cboxBitSelection1.getModel().setSelectedItem(prevValue);
		}
    }//GEN-LAST:event_cboxBitSelectionActionPerformed

	
	private boolean initPicLoaded() {
		if (initImage.getBufferedImage() == null) {
			JOptionPane.showMessageDialog(this, "No initial image");
			return false;
		}
		return true;
	}
	
	/**
	 * @param args the command line arguments
	 */
	public static void main(String args[]) {
		/* Set the Nimbus look and feel */
		//<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
		/* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
		 * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
		 */
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
			java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		}
		//</editor-fold>
		
		//</editor-fold>

		/* Create and display the form */
		java.awt.EventQueue.invokeLater(() -> {
			new MainWindow().setVisible(true);
		});
	}
	
	public static final int customRound(Double input) {
		return (int) Math.floor(input + 0.5);
	}
	
	public static final int evenRound(Double input) {
		return (int) Math.floor(input + 0.49);
	}
	
	private void setNewImage(int newImageValues[][], int imageToSet) {
		if (newImageValues.length > 0) {
			int newWidth = newImageValues.length;
			int newHeight = newImageValues[0].length;
			Dimension d = new Dimension(newWidth, newHeight);
			BufferedImage newBImg = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_RGB);

			for (int i = 0; i < newWidth; i++) {
				for (int j = 0; j < newHeight; j++) {
					int gr = newImageValues[i][j];

					Color gColor = new Color(gr, gr, gr);
					newBImg.setRGB(i, j, gColor.getRGB());
				}
			}

			if (imageToSet == MainWindow.NEW_IMAGE) {
				labelNewImage.setSize(d);
				labelNewImage.setIcon(new ImageIcon(newBImg));
			}
			else if (imageToSet == MainWindow.INIT_IMAGE) {
				labelInitImage.setSize(d);
				labelInitImage.setIcon(new ImageIcon(newBImg));
			}
		}
	}
	
	private void setNewImage(int newImageValues[][], int imageToSet, int keys[][]) {
		if (newImageValues.length > 0) {
			int newWidth = newImageValues.length;
			int newHeight = newImageValues[0].length;
			Dimension d = new Dimension(newWidth, newHeight);
			BufferedImage newBImg = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_RGB);

			for (int i = 0; i < newWidth; i++) {
				for (int j = 0; j < newHeight; j++) {
					int gr = newImageValues[i][j];

					Color gColor = new Color(gr, gr, gr);
					newBImg.setRGB(i, j, gColor.getRGB());
				}
			}
			
			System.out.println("Coloring edges...");
			System.out.println(keys.length);
			for (int coords[] : keys) {
				int i = coords[0];
				int j = coords[1];
				Color red = new Color(255,0,0);
				newBImg.setRGB(i, j, red.getRGB());
			}

			if (imageToSet == MainWindow.NEW_IMAGE) {
				labelNewImage.setSize(d);
				labelNewImage.setIcon(new ImageIcon(newBImg));
			}
			else if (imageToSet == MainWindow.INIT_IMAGE) {
				labelInitImage.setSize(d);
				labelInitImage.setIcon(new ImageIcon(newBImg));
			}
		}
	}
	
	// Pad the image with 0s
	public static final int[][] paddedImage(final int inputArr[][], int maskSize) {
		int oneDir = maskSize >> 1; // how far to go in one direction
		int newWidth = inputArr.length + maskSize - 1;
		int newHeight = inputArr[0].length + maskSize - 1;
		int paddedImage[][] = new int[newWidth][newHeight];
		
		for (int i = 0; i < newWidth; i++) {
			for (int j = 0; j < newHeight; j++) {
				// Pad the top and bottom rows and left and right columns with 0s
				if (i < oneDir || i >= (newWidth - oneDir) ||
					j < oneDir || j >= (newHeight - oneDir)) {
					paddedImage[i][j] = 0;
				}
				// Fill in the rest
				else {
					paddedImage[i][j] = inputArr[i-oneDir][j-oneDir];
				}
			}
		}
		
		return paddedImage;
	}
	
	// Pad the image with 0s
	public static final double[][] paddedImage(final double inputArr[][], int maskSize) {
		int oneDir = maskSize >> 1; // how far to go in one direction
		int newWidth = inputArr.length + maskSize - 1;
		int newHeight = inputArr[0].length + maskSize - 1;
		double paddedImage[][] = new double[newWidth][newHeight];
		
		for (int i = 0; i < newWidth; i++) {
			for (int j = 0; j < newHeight; j++) {
				// Pad the top and bottom rows and left and right columns with 0s
				if (i < oneDir || i >= (newWidth - oneDir) ||
					j < oneDir || j >= (newHeight - oneDir)) {
					paddedImage[i][j] = 0;
				}
				// Fill in the rest
				else {
					paddedImage[i][j] = inputArr[i-oneDir][j-oneDir];
				}
			}
		}
		
		return paddedImage;
	}
	
	public static void printImageArray(int imageArr[][]) {
		for (int[] imageArr1 : imageArr) {
			for (int col = 0; col < imageArr1.length; col++) {
				System.out.print(String.format("%3d ", imageArr1[col]));
			}
			System.out.print("\n");
		}
		System.out.print("\n");
	}
	
	public static void printImageArray(double imageArr[][]) {
		for (double[] imageArr1 : imageArr) {
			for (int col = 0; col < imageArr1.length; col++) {
				System.out.print(String.format("%.4f ", imageArr1[col]));
			}
			System.out.print("\n");
		}
		System.out.print("\n");
	}
	
	/**
	 * Get a local area of the image with size maskSize x maskSize
	 * @param paddedImage The PADDED image
	 * @param centerI The PADDED image's center i index
	 * @param centerJ The PADDED image's center j index
	 * @param maskSize Current mask size
	 * @return The local area of the image
	 */
	public static final int[][] getLocalArea(int paddedImage[][],
			int centerI, int centerJ, int maskSize) {
		int oneDir = maskSize >> 1;
		int localArea[][] = new int[maskSize][maskSize];
		
		for (int i = 0; i < maskSize; i++) {
			int initRowIndex = centerI + i;
			for (int j = 0; j < maskSize; j++) {
				int initColIndex = centerJ + j;
				localArea[i][j] = paddedImage[initRowIndex][initColIndex];
			}
		}
		
		return localArea;
	}
	
	public static final double[][] getLocalArea(double paddedImage[][],
			int centerI, int centerJ, int maskSize) {
		int oneDir = maskSize >> 1;
		double localArea[][] = new double[maskSize][maskSize];
		
		for (int i = 0; i < maskSize; i++) {
			int initRowIndex = centerI + i;
			for (int j = 0; j < maskSize; j++) {
				int initColIndex = centerJ + j;
				localArea[i][j] = paddedImage[initRowIndex][initColIndex];
			}
		}
		
		return localArea;
	}
	
	public static final int[][] getLocalAreaNoMask(int inputArray[][],
			int centerI, int centerJ, int maskSize) {
		int oneDir = maskSize >> 1;
		int width = inputArray.length;
		int height = inputArray[0].length;
		ArrayList<Integer> widthIndices = new ArrayList<>();
		ArrayList<Integer> heightIndices = new ArrayList<>();
		
		// Analyze the indices surrounding the centerI
		for (int i = -(oneDir); i <= oneDir; i++) {
			// See which indices are suitable
			int tempWidth = centerI + i;
			if (tempWidth >= 0 && tempWidth < width) {
				widthIndices.add(tempWidth);
			}
		}
		// Analyze the indices surrounding the centerJ
		for (int j = -(oneDir); j <= oneDir; j++) {
			// Only analyze j if j is suitable
			int tempHeight = centerJ + j;
			if (tempHeight >= 0 && tempHeight < height) {
				heightIndices.add(tempHeight);
			}
		}
		
		int newWidth = widthIndices.size();
		int newHeight = heightIndices.size();
		int localArea[][] = new int[newWidth][newHeight];
				
		for (int i = 0; i < newWidth; i++) {
			for (int j = 0; j < newHeight; j++) {
				localArea[i][j] = inputArray[widthIndices.get(i)][heightIndices.get(j)];
			}
		}
		
		return localArea;
	}
	
	/**
	 * 
	 * @param initImage
	 * @param mask
	 * @param convolve
	 * @return 
	 */
	public static final double[][] convolveOrCorrelate(int initImage[][],
			double mask[][], boolean convolve) {
		// Flip mask if it is a convolution
		if (convolve) {
			mask = flipMask(mask);
		}
		int width = initImage.length;
		int height = initImage[0].length;
		int maskSize = mask.length;
		double convertedImg[][] = new double[width][height];
		int paddedImage[][] = MainWindow.paddedImage(initImage, maskSize);
		double min = 262144;
		double max = -(min);
		
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				int localArea[][] = MainWindow.getLocalArea(paddedImage,
						i, j, maskSize);
				
				double total_temp = 0.0;
				for (int ii = 0; ii < maskSize; ii++) {
					for (int jj = 0; jj < maskSize; jj++) {
						double temp = localArea[ii][jj] * mask[ii][jj];
						total_temp += temp;
					}
				}
				if (total_temp > max) max = total_temp;
				if (total_temp < min) min = total_temp;
				convertedImg[i][j] = total_temp;
			}
		}
		
		return convertedImg;
	}
	
	public static final double[][] convolveOrCorrelate(double initImage[][],
			double mask[][], boolean convolve) {
		// Flip mask if it is a convolution
		if (convolve) {
			mask = flipMask(mask);
		}
		int width = initImage.length;
		int height = initImage[0].length;
		int maskSize = mask.length;
		double convertedImg[][] = new double[width][height];
		double paddedImage[][] = MainWindow.paddedImage(initImage, maskSize);
		double min = 262144;
		double max = -(min);
		
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				double localArea[][] = MainWindow.getLocalArea(paddedImage,
						i, j, maskSize);
				
				double total_temp = 0.0;
				for (int ii = 0; ii < maskSize; ii++) {
					for (int jj = 0; jj < maskSize; jj++) {
						double temp = localArea[ii][jj] * mask[ii][jj];
						total_temp += temp;
					}
				}
				if (total_temp > max) max = total_temp;
				if (total_temp < min) min = total_temp;
				convertedImg[i][j] = total_temp;
			}
		}
		
		return convertedImg;
	}
	
	/**
	 * 
	 * @param localArea
	 * @param mask
	 * @param convolve True if convolution, false if correlation
	 * @return 
	 */
	public static final double convolveOrCorrelateLocal(int localArea[][],
			double mask[][], boolean convolve) {
		if (localArea.length != mask.length) {
			System.out.println("Local area and mask size are not the same!");
			return -1;
		}
		
		// Flip mask if it is a convolution
		if (convolve) {
			mask = flipMask(mask);
		}
		
		int width = localArea.length;
		int height = localArea[0].length;
		int maskSize = mask.length;
		double res = 0.0;
		
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				double temp = localArea[i][j] * mask[i][j];
				res += temp;
			}
		}
		
		return res;
	}
	
	private static double[][] flipMask(double mask[][]) {
		int maskSize = mask.length;
		int radius = maskSize >> 1;
				
		// Flip in the x direction
		for (int i = 0; i < maskSize; i++) {
			for (int j = 1; j <= radius; j++) {
				double temp = mask[i][radius-j];
				mask[i][radius-j] = mask[i][radius+j];
				mask[i][radius+j] = temp;
			}
		}
		
		// Flip in the y direction
		for (int i = 0; i < maskSize; i++) {
			for (int j = 1; j <= radius; j++) {
				double temp = mask[radius-j][i];
				mask[radius-j][i] = mask[radius+j][i];
				mask[radius+j][i] = temp;
			}
		}
		
		return mask;
	}
	
	public static final int[][] scaledRgbInt(double image[][]) {
		double min = 262144;
		double max = -(min);
		int width = image.length;
		int height = image[0].length;
		int convertedImage[][] = new int[width][height];
		
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				double result = image[i][j];
				if (result > max) max = result;
				if (result < min) min = result;
			}
		}
		// Adjust the numbers
		double adjustedMax = max - min;
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				double temp = image[i][j] - min;
				temp = temp / adjustedMax;
				int result = MainWindow.customRound(temp * MainWindow.MAX_GRAYSCALE_VALUE);
				if (result > MainWindow.MAX_GRAYSCALE_VALUE)
					result = MainWindow.MAX_GRAYSCALE_VALUE;
				
				convertedImage[i][j] = result;
			}
		}
		
		return convertedImage;
	}
	
	public static final double[][] scaledRgbDouble(double image[][]) {
		double min = 262144;
		double max = -(min);
		int width = image.length;
		int height = image[0].length;
		
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				double result = image[i][j];
				if (result > max) max = result;
				if (result < min) min = result;
			}
		}
		// Adjust the numbers
		double adjustedMax = max - min;
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				double temp = image[i][j] - min;
				temp = temp / adjustedMax;
				int result = MainWindow.customRound(temp * MainWindow.MAX_GRAYSCALE_VALUE);
				if (result > MainWindow.MAX_GRAYSCALE_VALUE)
					result = MainWindow.MAX_GRAYSCALE_VALUE;
				
				image[i][j] = result;
			}
		}
		
		return image;
	}
	
	public static final void debugPrint(Object o) {
		System.out.println("DEBUG: " + o);
	}

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnConvertInit;
    private javax.swing.JButton btnExecute;
    private javax.swing.JButton btnInsertImage;
    private javax.swing.JComboBox<String> cboxAction;
    private javax.swing.JComboBox<String> cboxAlgo;
    private javax.swing.JComboBox<Integer> cboxBitSelection;
    private javax.swing.JComboBox<Integer> cboxBitSelection1;
    private javax.swing.JCheckBox jCheckHistogram;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabelBits1;
    private javax.swing.JLabel jLabelBits2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel labelInitImage;
    private javax.swing.JLabel labelNewImage;
    private javax.swing.JLabel lblText1;
    private javax.swing.JLabel lblText2;
    private javax.swing.JTextField textFieldHeight;
    private javax.swing.JTextField textFieldWidth;
    // End of variables declaration//GEN-END:variables
	private InitImage initImage;
	private javax.swing.JFileChooser jFileChooser1;
	private int convertedImage[][];
	private int currentConvBit = -1;
	public static final int INIT_IMAGE = 0;
	public static final int NEW_IMAGE = 1;
	public static final int MAX_GRAYSCALE_VALUE = 255;
	public static final int MAX_BIT = 8;
	public static final String[] HIST_CHOICES = {"Global", "Local 3x3", "Local 5x5", "Local 7x7", "Local 9x9"};
	public static final String[] ACTION_CHOICES = {"Gaussian Blur", "Canny Edge Detector", "Adaptive Canny Blurring",
	"Adaptive Canny"};
}